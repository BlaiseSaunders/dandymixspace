<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dandy Mix Space</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>
    <div id='container'>
    <div id="info">Description</div>
    <script type="text/javascript" src="./pcm-player.js"></script>

    <script type='module'>

        import * as THREE from '../build/three.module.js';
        import Stats from './jsm/libs/stats.module.js';
        import { OrbitControls } from './jsm/controls/OrbitControls.js';
        import { NormalMapShader } from './jsm/shaders/NormalMapShader.js';
        import { TerrainShader } from './jsm/shaders/TerrainShader.js';
        import { BufferGeometryUtils } from './jsm/utils/BufferGeometryUtils.js';



        function vertexShader() 
        {
            return `
            float PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   
            float PI  = 3.14159265358979323846264 * 00000.1; // PI
            float SQ2 = 1.41421356237309504880169 * 10000.0; // Square Root of Two

            uniform float offset;

            float gold_noise(in vec2 coordinate, in float seed){
                return fract(tan(distance(coordinate*(seed+PHI), vec2(PHI, PI)))*SQ2);
            }
            varying vec3 vUv; 

            void main()
            {
                vec3 pos = position;

                pos.z += gold_noise(vec2(pos.x, pos.y+offset), 1.0);

                vUv = pos; 

                vec4 modelViewPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * modelViewPosition; 
            }
            `
        }
        function fragmentShader() 
        {
            return `
                uniform vec3 colorA; 
                uniform vec3 colorB; 
                varying vec3 vUv;

                void main()
                {
                    gl_FragColor = vec4(0.0, 0.0, vUv.z, 1.0);
                }
        `
        }


        var camera, scene, renderer, controls;
        var mesh;
        var boxes = []
        var fftboxes = []
        window.data = []
        var box_count = 2048; // Must be half FFT size
        window.box_count = box_count;
        var stats;

        init();
        animate();

        var line;
        var cube;
        var meme_mesh;

        var uniforms;

        function setupKeyControls() 
        {
            window.ncube = meme_mesh;
            document.onkeydown = function(e) 
            {
                var ncube = window.ncube;
                console.log(ncube.rotation);
                console.log('HEY FUCKHEAD');
                switch (e.key)
                {
                    case 'ArrowLeft':
                        ncube.rotation.x += 0.1;
                        break;
                    case 'ArrowUp':
                        ncube.rotation.z -= 0.1;
                        break;
                    case 'ArrowRight':
                        ncube.rotation.x -= 0.1;
                        break;
                    case 'ArrowDown':
                        ncube.rotation.z += 0.1;
                        break;
                    case 'd':
                        ncube.rotation.y += 0.1;
                        break;
                    case 'a':
                        ncube.rotation.y -= 0.1;
                        break;
                }
                
            };
        }


        function init() {
            console.log("init")
           

                    
            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 10);
            camera.position.z = 1;
            

            scene = new THREE.Scene();

            boxes = []
            fftboxes = []
            for (let i = 0; i < box_count; i++)
            {
                var size = 0.005;
                var width = 2.4;

                var geometry = new THREE.BoxGeometry(size, size, size);
                var material = new THREE.MeshNormalMaterial();

                mesh = new THREE.Mesh(geometry, material);
                
                mesh.position.x = width / box_count * i - width/2;
                mesh.position.y = -0.8;
                scene.add(mesh);
                fftboxes[i] = mesh;
            }


            var geometry = new THREE.BufferGeometry();
            var indices = [];
            var vertices = [];
            var normals = [];
            var colors = [];
            var size = 2;
            var segments = 128;
            var halfSize = size / 2;
            var segmentSize = size / segments;
            // generate vertices, normals and color data for a simple grid geometry
            for ( var i = 0; i <= segments; i ++ ) {
                var y = ( i * segmentSize ) - halfSize;
                for ( var j = 0; j <= segments; j ++ ) {
                    var x = ( j * segmentSize ) - halfSize;
                    vertices.push( x, - y, 0 );
                    normals.push( 0, 0, 1 );
                    var r = ( x / size ) + 0.5;
                    var g = ( y / size ) + 0.5;
                    colors.push( r, g, 1 );
                }
            }
            // generate indices (data for element array buffer)
            for ( var i = 0; i < segments; i ++ ) {
                for ( var j = 0; j < segments; j ++ ) {
                    var a = i * ( segments + 1 ) + ( j + 1 );
                    var b = i * ( segments + 1 ) + j;
                    var c = ( i + 1 ) * ( segments + 1 ) + j;
                    var d = ( i + 1 ) * ( segments + 1 ) + ( j + 1 );
                    // generate two faces (triangles) per iteration
                    indices.push( a, b, d ); // face one
                    indices.push( b, c, d ); // face two
                }
            }

            geometry.setIndex(indices);
            geometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.dynamic = true;

            uniforms = {
                colorB: {type: 'vec3', value: new THREE.Color(0xACB6E5)},
                colorA: {type: 'vec3', value: new THREE.Color(0x74ebd5)},
                offset: {type: 'float', value: 0.0}
            }            

            var material = new THREE.MeshPhongMaterial({ side: THREE.DoubleSide, vertexColors: THREE.VertexColors });
            material = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
            material =  new THREE.ShaderMaterial({
                uniforms: uniforms,
                fragmentShader: fragmentShader(),
                vertexShader: vertexShader(),
            })
            meme_mesh = new THREE.Mesh(geometry, material);
            meme_mesh.dynamic = true;
            scene.add(meme_mesh);

            // Line
            // geometry
            var line_geometry = new THREE.BufferGeometry();

            // attributes
            var positions = new Float32Array( box_count * 3 ); // 3 vertices per point
            line_geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));

            // draw range
            var drawCount = box_count; // draw the first ALL OF THE points, only
            line_geometry.setDrawRange(0, drawCount);

            // material
            var material = new THREE.LineBasicMaterial( { color: 0xff0000, linewidth: 2 } );

            // line
            line = new THREE.Line(line_geometry,  material);
            scene.add(line);

            updatePositions(box_count);

            cube = new THREE.Mesh(new THREE.CubeGeometry(0.5, 0.5, 0.5), new THREE.MeshNormalMaterial());
            scene.add(cube);



            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            window.addEventListener( 'resize', onWindowResize, false );
           
            
            stats = new Stats();
            document.getElementById('container').appendChild(stats.dom);
            

            setupKeyControls();
            var scale = 0.2;
            meme_mesh.scale.x = scale;
            meme_mesh.scale.y = scale;
            meme_mesh.scale.z = scale;


            cube.position.x = 0.3;
            cube.position.y = -0.2;
            meme_mesh.scale.x = 1;
            meme_mesh.scale.y = 1;
            meme_mesh.position.x = 0;
            meme_mesh.position.y = -0.5;
            meme_mesh.position.z = -1;
            meme_mesh.rotation.x = -Math.PI/2+0.1;


        }

        // update positions
        function updatePositions(count, data = new Float32Array(count)) 
        {

            var positions = line.geometry.attributes.position.array;

            var index = 0, x = 0, y = 0, z = 0, pos = 0;

            for (var i = 0, l = count; i < l; i++) 
            {

                var width = 2.4;
                pos = (data[i])*0.2+0.4;
                x = width / count * i - width/2;
                y = pos;

                positions[ index ++ ] = x;
                positions[ index ++ ] = y;
                positions[ index ++ ] = z;

            }
            line.geometry.attributes.position.needsUpdate = true;

        }


        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }


        var SPEED = 0.01;

        function rotateCube() 
        {
            cube.rotation.x -= SPEED * 2;
            cube.rotation.y -= SPEED;
            cube.rotation.z -= SPEED * 3;
        }



        var startOff = Date.now();
        var analyser;
        var bufferLength;
        var dataArray;    
        var avglen = 1;
        var avgpos = 0;
        var thresh = 0.15;
        var avgfull = false;
        var avgavg = [avglen];
        var pretotal = 0;
        function animate() {
            meme_mesh.geometry.verticesNeedUpdate = true;
            requestAnimationFrame(animate);

            meme_mesh.material.uniforms.offset.value += 0.1;

            var player = window.pcm;
            if (typeof player === "undefined" || typeof player.sources[player.current] === "undefined" ||
                typeof player.sources[player.current].buffer === "undefined")
            {
                return;
            }
            if (typeof analyser === "undefined")
            {
                analyser = player.analyser;
                bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
            }

            
            var buf = player.sources[player.current].buffer;
            var data = new Float32Array(box_count);
            var start = (Date.now()-startOff)*(44100/1000);

            
            analyser.getByteFrequencyData(dataArray);
            
            //console.log(start);

            if (start > buf.length-box_count)            
                start = buf.length-box_count;
            buf.copyFromChannel(data, 0, start);

            if (player.reset)
            {
                startOff = Date.now();
                player.reset = false;
                //console.log("reset")
            }

            var avg = 0;
            var lowpass = 16;
            var fftOff = 10;
            var i, pos;
            for (i = fftOff; i < box_count/lowpass; i++)
            {           
                avg += dataArray[i]; 
                pos = (dataArray[i])/255 * 0.8 - 0.6;
                fftboxes[i].position.y = pos;
            }
            avg /= box_count/lowpass - fftOff;
            avgavg[avgpos] = avg;
            var totalavg = 0;
            var text;
            if (avgpos < avglen)
                avgpos++;
            else
            {
                avgpos = 0;
                var tmpavg = 0;
                for (let i = 0; i < avglen; i++)
                    tmpavg = avgavg[i]
                tmpavg /= avglen;
                
                totalavg = tmpavg;
                
                text = totalavg/pretotal*100


                var size = 0;
                if (totalavg / pretotal - 1 > thresh)
                {
                    text = 'BEAT';
                    size = totalavg/pretotal-1;
                    
                }
                if (size === 0)
                    size = 0.00001;
                cube.scale.x = size;
                cube.scale.y = size;
                cube.scale.z = size;

                document.getElementById('info').innerHTML = text;


                pretotal = totalavg;
            }
           
            
            
            /*meme_mesh.rotation.x = cube.rotation.x;
            meme_mesh.rotation.y = cube.rotation.y;
            meme_mesh.rotation.z = cube.rotation.z;*/
            //console.log(meme_mesh.rotation);

            

            updatePositions(box_count, data);

            rotateCube();

            renderer.render(scene, camera);
            stats.update();

        }

    </script>


<script>

function handleError()
{

}

 window.onload = function() {
   var socketURL = 'ws://localhost:8080';
   var player = new PCMPlayer({
        encoding: '16bitInt',
        channels: 2,
        sampleRate: 44100,
        flushingTime: 1000
   });

   var ws = new WebSocket(socketURL);
       
       ws.binaryType = 'arraybuffer';
       ws.addEventListener('message',function(event) {
            var data = new Uint16Array(event.data);
            player.feed(data);
            // Now FFT the data 

       });
 }   
</script>
</div>
</body>
</html>

